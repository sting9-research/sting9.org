// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package database

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type SubmissionStatus string

const (
	SubmissionStatusPending    SubmissionStatus = "pending"
	SubmissionStatusProcessing SubmissionStatus = "processing"
	SubmissionStatusProcessed  SubmissionStatus = "processed"
	SubmissionStatusFlagged    SubmissionStatus = "flagged"
	SubmissionStatusApproved   SubmissionStatus = "approved"
	SubmissionStatusRejected   SubmissionStatus = "rejected"
)

func (e *SubmissionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubmissionStatus(s)
	case string:
		*e = SubmissionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SubmissionStatus: %T", src)
	}
	return nil
}

type NullSubmissionStatus struct {
	SubmissionStatus SubmissionStatus `json:"submission_status"`
	Valid            bool             `json:"valid"` // Valid is true if SubmissionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubmissionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SubmissionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubmissionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubmissionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubmissionStatus), nil
}

type SubmissionType string

const (
	SubmissionTypeEmail       SubmissionType = "email"
	SubmissionTypeSms         SubmissionType = "sms"
	SubmissionTypeWhatsapp    SubmissionType = "whatsapp"
	SubmissionTypeTelegram    SubmissionType = "telegram"
	SubmissionTypeSignal      SubmissionType = "signal"
	SubmissionTypeSocialMedia SubmissionType = "social_media"
	SubmissionTypeOther       SubmissionType = "other"
)

func (e *SubmissionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubmissionType(s)
	case string:
		*e = SubmissionType(s)
	default:
		return fmt.Errorf("unsupported scan type for SubmissionType: %T", src)
	}
	return nil
}

type NullSubmissionType struct {
	SubmissionType SubmissionType `json:"submission_type"`
	Valid          bool           `json:"valid"` // Valid is true if SubmissionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubmissionType) Scan(value interface{}) error {
	if value == nil {
		ns.SubmissionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubmissionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubmissionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubmissionType), nil
}

type UserRole string

const (
	UserRoleResearcher UserRole = "researcher"
	UserRolePartner    UserRole = "partner"
	UserRoleAdmin      UserRole = "admin"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"user_role"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type ApiToken struct {
	ID         uuid.UUID          `json:"id"`
	UserID     uuid.UUID          `json:"user_id"`
	TokenHash  string             `json:"token_hash"`
	ExpiresAt  time.Time          `json:"expires_at"`
	Revoked    *bool              `json:"revoked"`
	RevokedAt  pgtype.Timestamptz `json:"revoked_at"`
	LastUsedAt pgtype.Timestamptz `json:"last_used_at"`
	UserAgent  *string            `json:"user_agent"`
	IpAddress  *string            `json:"ip_address"`
	CreatedAt  time.Time          `json:"created_at"`
}

type Statistic struct {
	ID                    int32     `json:"id"`
	TotalSubmissions      *int64    `json:"total_submissions"`
	SubmissionsByType     []byte    `json:"submissions_by_type"`
	SubmissionsByCategory []byte    `json:"submissions_by_category"`
	SubmissionsByStatus   []byte    `json:"submissions_by_status"`
	LanguagesDetected     []byte    `json:"languages_detected"`
	SubmissionsByDate     []byte    `json:"submissions_by_date"`
	UpdatedAt             time.Time `json:"updated_at"`
}

type Submission struct {
	ID                uuid.UUID            `json:"id"`
	Type              SubmissionType       `json:"type"`
	RawContent        string               `json:"raw_content"`
	AnonymizedContent *string              `json:"anonymized_content"`
	Metadata          []byte               `json:"metadata"`
	Language          *string              `json:"language"`
	Category          *string              `json:"category"`
	Status            NullSubmissionStatus `json:"status"`
	SubmitterIp       *string              `json:"submitter_ip"`
	UserAgent         *string              `json:"user_agent"`
	CreatedAt         time.Time            `json:"created_at"`
	ProcessedAt       pgtype.Timestamptz   `json:"processed_at"`
	UpdatedAt         time.Time            `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz   `json:"deleted_at"`
	// Email address of the person submitting the phishing/smishing content
	SubmitterEmail *string `json:"submitter_email"`
}

type User struct {
	ID                    uuid.UUID          `json:"id"`
	Email                 string             `json:"email"`
	PasswordHash          string             `json:"password_hash"`
	Role                  NullUserRole       `json:"role"`
	Organization          *string            `json:"organization"`
	Purpose               *string            `json:"purpose"`
	Verified              *bool              `json:"verified"`
	Approved              *bool              `json:"approved"`
	VerificationToken     *string            `json:"verification_token"`
	VerificationExpiresAt pgtype.Timestamptz `json:"verification_expires_at"`
	ResetToken            *string            `json:"reset_token"`
	ResetExpiresAt        pgtype.Timestamptz `json:"reset_expires_at"`
	LastLoginAt           pgtype.Timestamptz `json:"last_login_at"`
	CreatedAt             time.Time          `json:"created_at"`
	UpdatedAt             time.Time          `json:"updated_at"`
	DeletedAt             pgtype.Timestamptz `json:"deleted_at"`
}
