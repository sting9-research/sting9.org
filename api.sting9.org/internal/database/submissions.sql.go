// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: submissions.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countSubmissions = `-- name: CountSubmissions :one
SELECT COUNT(*) FROM submissions WHERE deleted_at IS NULL
`

func (q *Queries) CountSubmissions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSubmissions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSubmissionsByCategory = `-- name: CountSubmissionsByCategory :one
SELECT COUNT(*) FROM submissions WHERE category = $1 AND deleted_at IS NULL
`

func (q *Queries) CountSubmissionsByCategory(ctx context.Context, category *string) (int64, error) {
	row := q.db.QueryRow(ctx, countSubmissionsByCategory, category)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSubmissionsByType = `-- name: CountSubmissionsByType :one
SELECT COUNT(*) FROM submissions WHERE type = $1 AND deleted_at IS NULL
`

func (q *Queries) CountSubmissionsByType(ctx context.Context, type_ SubmissionType) (int64, error) {
	row := q.db.QueryRow(ctx, countSubmissionsByType, type_)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSubmission = `-- name: CreateSubmission :one
INSERT INTO submissions (
    type, raw_content, anonymized_content, metadata, language, category, status, submitter_ip, user_agent, submitter_email
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, type, raw_content, anonymized_content, metadata, language, category, status, submitter_ip, user_agent, created_at, processed_at, updated_at, deleted_at, submitter_email
`

type CreateSubmissionParams struct {
	Type              SubmissionType       `json:"type"`
	RawContent        string               `json:"raw_content"`
	AnonymizedContent *string              `json:"anonymized_content"`
	Metadata          []byte               `json:"metadata"`
	Language          *string              `json:"language"`
	Category          *string              `json:"category"`
	Status            NullSubmissionStatus `json:"status"`
	SubmitterIp       *string              `json:"submitter_ip"`
	UserAgent         *string              `json:"user_agent"`
	SubmitterEmail    *string              `json:"submitter_email"`
}

func (q *Queries) CreateSubmission(ctx context.Context, arg CreateSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, createSubmission,
		arg.Type,
		arg.RawContent,
		arg.AnonymizedContent,
		arg.Metadata,
		arg.Language,
		arg.Category,
		arg.Status,
		arg.SubmitterIp,
		arg.UserAgent,
		arg.SubmitterEmail,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.RawContent,
		&i.AnonymizedContent,
		&i.Metadata,
		&i.Language,
		&i.Category,
		&i.Status,
		&i.SubmitterIp,
		&i.UserAgent,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.SubmitterEmail,
	)
	return i, err
}

const deleteSubmission = `-- name: DeleteSubmission :exec
UPDATE submissions
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteSubmission(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSubmission, id)
	return err
}

const getLeaderboard = `-- name: GetLeaderboard :many
SELECT
    submitter_email,
    COUNT(*) as submission_count
FROM submissions
WHERE deleted_at IS NULL
    AND submitter_email IS NOT NULL
    AND submitter_email != ''
GROUP BY submitter_email
ORDER BY submission_count DESC
LIMIT 50
`

type GetLeaderboardRow struct {
	SubmitterEmail  *string `json:"submitter_email"`
	SubmissionCount int64   `json:"submission_count"`
}

func (q *Queries) GetLeaderboard(ctx context.Context) ([]GetLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, getLeaderboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLeaderboardRow{}
	for rows.Next() {
		var i GetLeaderboardRow
		if err := rows.Scan(&i.SubmitterEmail, &i.SubmissionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionByID = `-- name: GetSubmissionByID :one
SELECT id, type, raw_content, anonymized_content, metadata, language, category, status, submitter_ip, user_agent, created_at, processed_at, updated_at, deleted_at, submitter_email FROM submissions
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetSubmissionByID(ctx context.Context, id uuid.UUID) (Submission, error) {
	row := q.db.QueryRow(ctx, getSubmissionByID, id)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.RawContent,
		&i.AnonymizedContent,
		&i.Metadata,
		&i.Language,
		&i.Category,
		&i.Status,
		&i.SubmitterIp,
		&i.UserAgent,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.SubmitterEmail,
	)
	return i, err
}

const listSubmissions = `-- name: ListSubmissions :many
SELECT id, type, raw_content, anonymized_content, metadata, language, category, status, submitter_ip, user_agent, created_at, processed_at, updated_at, deleted_at, submitter_email FROM submissions
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListSubmissionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSubmissions(ctx context.Context, arg ListSubmissionsParams) ([]Submission, error) {
	rows, err := q.db.Query(ctx, listSubmissions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Submission{}
	for rows.Next() {
		var i Submission
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.RawContent,
			&i.AnonymizedContent,
			&i.Metadata,
			&i.Language,
			&i.Category,
			&i.Status,
			&i.SubmitterIp,
			&i.UserAgent,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.SubmitterEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubmissionsByCategory = `-- name: ListSubmissionsByCategory :many
SELECT id, type, raw_content, anonymized_content, metadata, language, category, status, submitter_ip, user_agent, created_at, processed_at, updated_at, deleted_at, submitter_email FROM submissions
WHERE category = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListSubmissionsByCategoryParams struct {
	Category *string `json:"category"`
	Limit    int32   `json:"limit"`
	Offset   int32   `json:"offset"`
}

func (q *Queries) ListSubmissionsByCategory(ctx context.Context, arg ListSubmissionsByCategoryParams) ([]Submission, error) {
	rows, err := q.db.Query(ctx, listSubmissionsByCategory, arg.Category, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Submission{}
	for rows.Next() {
		var i Submission
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.RawContent,
			&i.AnonymizedContent,
			&i.Metadata,
			&i.Language,
			&i.Category,
			&i.Status,
			&i.SubmitterIp,
			&i.UserAgent,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.SubmitterEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubmissionsByDateRange = `-- name: ListSubmissionsByDateRange :many
SELECT id, type, raw_content, anonymized_content, metadata, language, category, status, submitter_ip, user_agent, created_at, processed_at, updated_at, deleted_at, submitter_email FROM submissions
WHERE created_at >= $1 AND created_at <= $2 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListSubmissionsByDateRangeParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListSubmissionsByDateRange(ctx context.Context, arg ListSubmissionsByDateRangeParams) ([]Submission, error) {
	rows, err := q.db.Query(ctx, listSubmissionsByDateRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Submission{}
	for rows.Next() {
		var i Submission
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.RawContent,
			&i.AnonymizedContent,
			&i.Metadata,
			&i.Language,
			&i.Category,
			&i.Status,
			&i.SubmitterIp,
			&i.UserAgent,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.SubmitterEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubmissionsByStatus = `-- name: ListSubmissionsByStatus :many
SELECT id, type, raw_content, anonymized_content, metadata, language, category, status, submitter_ip, user_agent, created_at, processed_at, updated_at, deleted_at, submitter_email FROM submissions
WHERE status = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListSubmissionsByStatusParams struct {
	Status NullSubmissionStatus `json:"status"`
	Limit  int32                `json:"limit"`
	Offset int32                `json:"offset"`
}

func (q *Queries) ListSubmissionsByStatus(ctx context.Context, arg ListSubmissionsByStatusParams) ([]Submission, error) {
	rows, err := q.db.Query(ctx, listSubmissionsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Submission{}
	for rows.Next() {
		var i Submission
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.RawContent,
			&i.AnonymizedContent,
			&i.Metadata,
			&i.Language,
			&i.Category,
			&i.Status,
			&i.SubmitterIp,
			&i.UserAgent,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.SubmitterEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubmissionsByType = `-- name: ListSubmissionsByType :many
SELECT id, type, raw_content, anonymized_content, metadata, language, category, status, submitter_ip, user_agent, created_at, processed_at, updated_at, deleted_at, submitter_email FROM submissions
WHERE type = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListSubmissionsByTypeParams struct {
	Type   SubmissionType `json:"type"`
	Limit  int32          `json:"limit"`
	Offset int32          `json:"offset"`
}

func (q *Queries) ListSubmissionsByType(ctx context.Context, arg ListSubmissionsByTypeParams) ([]Submission, error) {
	rows, err := q.db.Query(ctx, listSubmissionsByType, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Submission{}
	for rows.Next() {
		var i Submission
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.RawContent,
			&i.AnonymizedContent,
			&i.Metadata,
			&i.Language,
			&i.Category,
			&i.Status,
			&i.SubmitterIp,
			&i.UserAgent,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.SubmitterEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubmissionContent = `-- name: UpdateSubmissionContent :one
UPDATE submissions
SET anonymized_content = $2, language = $3, category = $4
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, type, raw_content, anonymized_content, metadata, language, category, status, submitter_ip, user_agent, created_at, processed_at, updated_at, deleted_at, submitter_email
`

type UpdateSubmissionContentParams struct {
	ID                uuid.UUID `json:"id"`
	AnonymizedContent *string   `json:"anonymized_content"`
	Language          *string   `json:"language"`
	Category          *string   `json:"category"`
}

func (q *Queries) UpdateSubmissionContent(ctx context.Context, arg UpdateSubmissionContentParams) (Submission, error) {
	row := q.db.QueryRow(ctx, updateSubmissionContent,
		arg.ID,
		arg.AnonymizedContent,
		arg.Language,
		arg.Category,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.RawContent,
		&i.AnonymizedContent,
		&i.Metadata,
		&i.Language,
		&i.Category,
		&i.Status,
		&i.SubmitterIp,
		&i.UserAgent,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.SubmitterEmail,
	)
	return i, err
}

const updateSubmissionStatus = `-- name: UpdateSubmissionStatus :one
UPDATE submissions
SET status = $2, processed_at = CASE WHEN $2 = 'processed' THEN NOW() ELSE processed_at END
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, type, raw_content, anonymized_content, metadata, language, category, status, submitter_ip, user_agent, created_at, processed_at, updated_at, deleted_at, submitter_email
`

type UpdateSubmissionStatusParams struct {
	ID     uuid.UUID            `json:"id"`
	Status NullSubmissionStatus `json:"status"`
}

func (q *Queries) UpdateSubmissionStatus(ctx context.Context, arg UpdateSubmissionStatusParams) (Submission, error) {
	row := q.db.QueryRow(ctx, updateSubmissionStatus, arg.ID, arg.Status)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.RawContent,
		&i.AnonymizedContent,
		&i.Metadata,
		&i.Language,
		&i.Category,
		&i.Status,
		&i.SubmitterIp,
		&i.UserAgent,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.SubmitterEmail,
	)
	return i, err
}
